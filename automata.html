<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Automata Simulator (AI integrated)</title>
<link rel="stylesheets" href="automatacss.css">
</head>
<body>

  <button id="info-btn" class="info-btn" title="Info">i</button>

  <h1>Automata Simulator — AI integrated</h1>

  <div class="top-row">
    <div id="canvas-wrapper">
      <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
      <div id="notification">
        <strong>Instructions</strong>
        <div style="margin-top:6px; font-size:13px;">
          • Click "Vertex" to add a state (label required).<br>
          • Click "Edge" to toggle transition mode; click source then target to add transition.<br>
          • Use "Self Loop" then click a state to add a self transition.<br>
          • Use the chat box below to ask the AI to edit the graph (example commands below).<br>
        </div>
      </div>

      <div class="btn-row">
        <button id="vertex-btn">Vertex</button>
        <button id="edge-btn">Edge</button>
        <button id="self-loop-btn">Self Loop</button>
        <button id="undo-btn">Undo</button>
        <button id="reset-btn">Reset</button>
        <button id="delete-btn">Delete</button>
      </div>

      <div style="margin-top:6px;">
        <label style="font-size:13px; color:#ccc;">AI Chat (try: "add state S at center", "make A final", "add transition A->B:0,1")</label>
        <textarea id="user-input" placeholder='Describe changes to the automaton (e.g. "add state A at 100,200" or "add transition q0->q1:0")'></textarea>
        <div style="display:flex; gap:8px; margin-top:6px;">
          <button id="aisubmitbtn">Ask AI & Apply</button>
          <button id="explain-btn">Ask AI for explanation (no changes)</button>
        </div>
        <div id="result" aria-live="polite"></div>
      </div>

      <div style="margin-top:10px;">
        <table>
          <tr><th>Feature</th><th>Present?</th></tr>
          <tr><td>Deterministic Automaton (DFA)</td><td><input id="deterministic" type="checkbox" disabled></td></tr>
          <tr><td>Non-deterministic (NFA)</td><td><input id="nondeterministic" type="checkbox" disabled></td></tr>
          <tr><td>Has ε transitions</td><td><input id="epsilon" type="checkbox" disabled></td></tr>
          <tr><td>Start state defined</td><td><input id="start-state" type="checkbox" disabled></td></tr>
          <tr><td>Accept state(s) present</td><td><input id="accept-state" type="checkbox" disabled></td></tr>
        </table>
      </div>
    </div>
  </div>

  <!-- small modal used by "Vertex" -->
  <div id="acceptModal">
    <p>Is this a final (accept) state?</p>
    <button id="yesBtn">Yes</button>
    <button id="noBtn">No</button>
  </div>

<script>
/* --------- CONFIG (replace key if needed) ---------- */
const AI_API_KEY = "AIzaSyC5ab-HZmvtoTEXMRBMb4-tPpwD2yMVF1A"; // <-- user-supplied key (rotate for production)
const AI_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${AI_API_KEY}`;

/* ---------- Automaton data model ----------
   states: [{ label, x, y, isStart, isAccept }]
   transitions: [{ from, to, symbols: [] }] // from/to are labels (strings)
   alphabet: Set of symbols
------------------------------------------- */
let automaton = {
  states: [],
  transitions: [],
  alphabet: new Set()
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resizeCanvasToDisplaySize() {
  const wrapper = document.getElementById('canvas-wrapper');
  const style = getComputedStyle(wrapper);
  const width = wrapper.clientWidth - 20;
  // keep aspect / height decent
  canvas.width = Math.max(600, Math.floor(width));
  canvas.height = Math.max(420, Math.floor(Math.min(window.innerHeight * 0.6, 720)));
}
window.addEventListener('resize', resizeCanvasToDisplaySize);
resizeCanvasToDisplaySize();

/* ---- Interaction state ---- */
let draggingState = null;
let offsetX = 0, offsetY = 0;
let isTransitionMode = false;
let transitionFromLabel = null;
let isSelfLoopMode = false;
let history = [];
let historyIndex = -1;

/* -------- Drawing -------- */
function stateByLabel(label) {
  return automaton.states.find(s => s.label === label);
}

function drawAutomaton() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw transitions (lines/arrows)
  automaton.transitions.forEach(t => {
    const from = stateByLabel(t.from);
    const to = stateByLabel(t.to);
    if (!from || !to) return;

    if (from.label === to.label) {
      // self loop
      ctx.beginPath();
      ctx.arc(from.x, from.y - 34, 20, 0, 2*Math.PI);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

      ctx.fillStyle = '#ff6666';
      ctx.font = '14px Arial'; ctx.textAlign='center';
      ctx.fillText(t.symbols.join(','), from.x, from.y - 62);
    } else {
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

      // arrow
      const angle = Math.atan2(to.y - from.y, to.x - from.x);
      const arrowSize = 10;
      ctx.beginPath();
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(to.x - arrowSize * Math.cos(angle - Math.PI/6), to.y - arrowSize * Math.sin(angle - Math.PI/6));
      ctx.lineTo(to.x - arrowSize * Math.cos(angle + Math.PI/6), to.y - arrowSize * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = '#fff'; ctx.fill();

      const midX = (from.x + to.x)/2;
      const midY = (from.y + to.y)/2;
      ctx.fillStyle = '#ff6666'; ctx.font='14px Arial'; ctx.textAlign='center';
      ctx.fillText(t.symbols.join(','), midX, midY - 10);
    }
  });

  // draw states
  automaton.states.forEach(s => {
    ctx.beginPath();
    ctx.arc(s.x, s.y, 25, 0, 2*Math.PI);
    ctx.fillStyle = '#ff6666';
    ctx.fill();

    if (s.isAccept) {
      ctx.lineWidth = 4; ctx.strokeStyle = '#ffd700';
      ctx.beginPath(); ctx.arc(s.x, s.y, 30, 0, 2*Math.PI); ctx.stroke();
    } else {
      ctx.lineWidth = 2; ctx.strokeStyle = '#ff6666';
      ctx.beginPath(); ctx.arc(s.x, s.y, 25, 0, 2*Math.PI); ctx.stroke();
    }

    if (s.isStart) {
      ctx.beginPath(); ctx.moveTo(s.x - 40, s.y); ctx.lineTo(s.x - 25, s.y); ctx.strokeStyle='black'; ctx.lineWidth=3; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x - 30, s.y - 7); ctx.lineTo(s.x - 40, s.y); ctx.lineTo(s.x - 30, s.y + 7); ctx.fillStyle='white'; ctx.fill();
    }

    ctx.fillStyle = 'white'; ctx.font='16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(s.label, s.x, s.y);
  });
}

setInterval(drawAutomaton, 80);

/* ---------- Mouse interaction ---------- */
function getMousePos(e) {
  const rect = canvas.getBoundingClientRect();
  return { x: e.clientX - rect.left, y: e.clientY - rect.top};
}

canvas.addEventListener('mousedown', (e) => {
  const pos = getMousePos(e);
  for (let s of automaton.states) {
    if (Math.hypot(pos.x - s.x, pos.y - s.y) < 25) {
      draggingState = s;
      offsetX = pos.x - s.x; offsetY = pos.y - s.y;
      break;
    }
  }
});
canvas.addEventListener('mousemove', (e) => {
  if (draggingState) {
    const pos = getMousePos(e);
    draggingState.x = pos.x - offsetX; draggingState.y = pos.y - offsetY;
  }
});
canvas.addEventListener('mouseup', (e) => {
  if (draggingState) saveHistory();
  draggingState = null;
});

/* click actions for transition and self loops */
canvas.addEventListener('click', (e) => {
  const pos = getMousePos(e);
  const clicked = automaton.states.find(s => Math.hypot(pos.x - s.x, pos.y - s.y) < 25);

  if (isTransitionMode) {
    if (!transitionFromLabel) {
      if (clicked) {
        transitionFromLabel = clicked.label;
        showTemporaryMessage(`Selected source: ${transitionFromLabel}. Now click destination state.`);
      }
    } else {
      if (clicked) {
        let symbol = prompt('Enter input symbol(s) separated by comma:');
        if (symbol) {
          const symbols = symbol.split(',').map(s => s.trim()).filter(Boolean);
          let existing = automaton.transitions.find(t => t.from === transitionFromLabel && t.to === clicked.label);
          if (existing) existing.symbols.push(...symbols);
          else automaton.transitions.push({ from: transitionFromLabel, to: clicked.label, symbols });
          symbols.forEach(s => automaton.alphabet.add(s));
          saveHistory();
        }
      }
      transitionFromLabel = null;
    }
    return;
  }

  if (isSelfLoopMode && clicked) {
    let symbol = prompt('Enter input symbol(s) separated by comma for self-loop:');
    if (symbol) {
      const symbols = symbol.split(',').map(s => s.trim()).filter(Boolean);
      let existing = automaton.transitions.find(t => t.from === clicked.label && t.to === clicked.label);
      if (existing) existing.symbols.push(...symbols);
      else automaton.transitions.push({ from: clicked.label, to: clicked.label, symbols });
      symbols.forEach(s => automaton.alphabet.add(s));
      saveHistory();
    }
    isSelfLoopMode = false;
    return;
  }
});

/* ---------- Buttons ---------- */
document.getElementById('edge-btn').addEventListener('click', () => {
  isTransitionMode = !isTransitionMode;
  transitionFromLabel = null;
  alert(isTransitionMode ? 'Transition Mode ON (click source then dest)' : 'Transition Mode OFF');
});

document.getElementById('self-loop-btn').addEventListener('click', () => {
  isSelfLoopMode = !isSelfLoopMode;
  alert(isSelfLoopMode ? 'Self-loop mode ON: click a state to add self-loop.' : 'Self-loop mode OFF');
});

document.getElementById('reset-btn').addEventListener('click', () => {
  automaton.states = []; automaton.transitions = []; automaton.alphabet = new Set();
  history = []; historyIndex = -1; updateCheckboxes(); saveHistory();
});

document.getElementById('undo-btn').addEventListener('click', () => {
  if (historyIndex > 0) {
    historyIndex--;
    const snapshot = history[historyIndex];
    automaton.states = JSON.parse(JSON.stringify(snapshot.states));
    automaton.transitions = JSON.parse(JSON.stringify(snapshot.transitions));
    automaton.alphabet = new Set(snapshot.alphabet);
    updateCheckboxes();
  } else {
    alert('No more history.');
  }
});

document.getElementById('vertex-btn').addEventListener('click', async () => {
  resizeCanvasToDisplaySize();
  const rect = canvas.getBoundingClientRect();
  const x = rect.width / 2;
  const y = rect.height / 2;

  let label = prompt("Enter unique state label (e.g. q0, A):");
  if (!label) return alert('Label required.');
  if (automaton.states.some(s => s.label === label)) return alert('Label must be unique.');

  let isStart = false;
  if (automaton.states.length === 0) {
    isStart = confirm('Make this the start state? (only one allowed)');
  }
  // ask accept modal
  const isAccept = await askAcceptState();
  if (isStart) automaton.states.forEach(s => s.isStart = false);
  automaton.states.push({ label, x: x, y: y, isStart, isAccept });
  saveHistory(); updateCheckboxes();
});

/* delete: click element to delete */
document.getElementById('delete-btn').addEventListener('click', () => {
  alert('Click the state you want to delete on the canvas.');
  const onClick = (e) => {
    const pos = getMousePos(e);
    const clickedIndex = automaton.states.findIndex(s => Math.hypot(pos.x - s.x, pos.y - s.y) < 25);
    if (clickedIndex >= 0) {
      const removed = automaton.states.splice(clickedIndex, 1)[0];
      // remove transitions referencing label
      automaton.transitions = automaton.transitions.filter(t => t.from !== removed.label && t.to !== removed.label);
      saveHistory(); updateCheckboxes();
    } else {
      // maybe clicked on transition: delete nearest transition if close to its mid point
      let found = null;
      for (let i=0;i<automaton.transitions.length;i++) {
        const t = automaton.transitions[i];
        const from = stateByLabel(t.from);
        const to = stateByLabel(t.to);
        if (!from || !to) continue;
        const midX = (from.x + to.x)/2, midY = (from.y + to.y)/2;
        if (Math.hypot(pos.x - midX, pos.y - midY) < 20) { found = i; break; }
      }
      if (found !== null) {
        automaton.transitions.splice(found,1); saveHistory();
      } else alert('Nothing deleted (click nearer a state or transition).');
    }
    canvas.removeEventListener('click', onClick, true);
  };
  canvas.addEventListener('click', onClick, true);
});

/* ---------- History helpers ---------- */
function saveHistory() {
  const snapshot = {
    states: JSON.parse(JSON.stringify(automaton.states)),
    transitions: JSON.parse(JSON.stringify(automaton.transitions)),
    alphabet: Array.from(automaton.alphabet)
  };
  history = history.slice(0, historyIndex + 1);
  history.push(snapshot); historyIndex++;
}

/* accept modal helper */
function askAcceptState() {
  return new Promise((resolve) => {
    const modal = document.getElementById('acceptModal');
    modal.style.display = 'block';
    const yes = document.getElementById('yesBtn'), no = document.getElementById('noBtn');
    function cleanup(choice) {
      modal.style.display = 'none';
      yes.removeEventListener('click', onYes);
      no.removeEventListener('click', onNo);
      resolve(choice);
    }
    function onYes(){ cleanup(true); }
    function onNo(){ cleanup(false); }
    yes.addEventListener('click', onYes); no.addEventListener('click', onNo);
  });
}

/* update small checkboxes */
function updateCheckboxes() {
  document.getElementById('deterministic').checked = true; // naive; you can improve detection
  document.getElementById('nondeterministic').checked = false;
  document.getElementById('epsilon').checked = automaton.transitions.some(t => t.symbols.includes('ε') || t.symbols.includes('epsilon'));
  document.getElementById('start-state').checked = automaton.states.some(s => s.isStart);
  document.getElementById('accept-state').checked = automaton.states.some(s => s.isAccept);
}

/* small helper to display messages */
function showTemporaryMessage(msg, ms = 2200) {
  const r = document.getElementById('result');
  r.textContent = msg;
  setTimeout(() => { r.textContent = ''; }, ms);
}

/* ---------- AI Integration ---------- */

/*
  Strategy:
  1) We send the user instruction + current automaton (serialized) to the model with a system prompt that *requires*
     returning JSON with an "actions" array. Each action is one of:
     - add_state {label,x,y,isStart,isAccept}
     - remove_state {label}
     - add_transition {from,to,symbols:[]}
     - remove_transition {from,to}
     - set_start {label}
     - set_accept {label, value:true/false}
     - move_state {label, x, y}
     - rename_state {oldLabel, newLabel}
  2) We parse the returned JSON and execute actions.
  3) If model doesn't return JSON, we display its text in result for user to copy/inspect.
*/

const aisubmitbtn = document.getElementById('aisubmitbtn');
const explainBtn = document.getElementById('explain-btn');
const userInputEl = document.getElementById('user-input');
const resultEl = document.getElementById('result');

function serializeAutomatonForPrompt() {
  return {
    states: automaton.states.map(s => ({ label:s.label, x: Math.round(s.x), y: Math.round(s.y), isStart:!!s.isStart, isAccept:!!s.isAccept })),
    transitions: automaton.transitions.map(t => ({ from:t.from, to:t.to, symbols:t.symbols })),
    alphabet: Array.from(automaton.alphabet)
  };
}

async function callAI(promptText) {
  const fullBody = {
    // The request format follows the Google generative API example: use input as "content" parts.
    // We're keeping request simple: pass user instruction as text. Model selection is in endpoint.
    temperature: 0.2,
    candidateCount: 1,
    // Provide a single text input block
    prompt: {
      // We will give the model a short system+user style instruction via text field.
      text: promptText
    }
  };

  const resp = await fetch(AI_ENDPOINT, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(fullBody)
  });

  if (!resp.ok) {
    const txt = await resp.text();
    throw new Error(`AI API error: ${resp.status} ${txt}`);
  }
  const data = await resp.json();
  // Try several access patterns to be robust:
  // model may return candidates[0].content.parts[0].text or output[0].content[0].text etc.
  let text = null;
  if (data?.candidates && data.candidates.length && data.candidates[0].content) {
    const parts = data.candidates[0].content;
    // parts may be an array of {type:'output_text', text:'...'} or {parts:[ {text:...} ] }
    if (Array.isArray(parts)) {
      for (const p of parts) {
        if (p?.text) { text = (text ? text + '\n' : '') + p.text; }
        if (p?.parts && Array.isArray(p.parts)) {
          for (const sub of p.parts) if (sub?.text) text = (text ? text + '\n' : '') + sub.text;
        }
      }
    } else if (parts?.parts && Array.isArray(parts.parts)) {
      text = parts.parts.map(pp => pp.text).join('\n');
    }
  }
  if (!text && data?.output && Array.isArray(data.output)) {
    text = data.output.map(o => o.content?.map(c => c.text).join('\n')).join('\n');
  }
  if (!text && typeof data?.text === 'string') text = data.text;

  return { raw: data, text };
}

function applyActions(actions) {
  let changed = false;
  for (const act of actions) {
    switch((act.type||'').toLowerCase()) {
      case 'add_state': {
        const lbl = act.label;
        if (!lbl) break;
        if (automaton.states.some(s=>s.label===lbl)) break;
        const x = act.x ?? (canvas.width/2 + (Math.random()-0.5)*120);
        const y = act.y ?? (canvas.height/2 + (Math.random()-0.5)*80);
        if (act.isStart) automaton.states.forEach(s=>s.isStart=false);
        automaton.states.push({ label: lbl, x, y, isStart:!!act.isStart, isAccept:!!act.isAccept });
        changed=true; break;
      }
      case 'remove_state': {
        const lbl = act.label;
        if (!lbl) break;
        automaton.states = automaton.states.filter(s => s.label !== lbl);
        automaton.transitions = automaton.transitions.filter(t => t.from !== lbl && t.to !== lbl);
        changed=true; break;
      }
      case 'add_transition': {
        const from = act.from, to = act.to;
        if (!from || !to) break;
        const symbols = Array.isArray(act.symbols) ? act.symbols.map(s=>String(s)) : (act.symbols ? String(act.symbols).split(',').map(s=>s.trim()) : []);
        let ex = automaton.transitions.find(t => t.from===from && t.to===to);
        if (ex) ex.symbols.push(...symbols);
        else automaton.transitions.push({ from, to, symbols });
        symbols.forEach(s => automaton.alphabet.add(s));
        changed=true; break;
      }
      case 'remove_transition': {
        const from = act.from, to = act.to;
        automaton.transitions = automaton.transitions.filter(t => !(t.from===from && t.to===to));
        changed=true; break;
      }
      case 'set_start': {
        const lbl = act.label;
        if (!lbl) break;
        automaton.states.forEach(s => s.isStart = (s.label === lbl));
        changed=true; break;
      }
      case 'set_accept': {
        const lbl = act.label; const val = !!act.value;
        const s = automaton.states.find(x => x.label===lbl);
        if (s) { s.isAccept = val; changed=true; }
        break;
      }
      case 'move_state': {
        const lbl = act.label; const s = automaton.states.find(x => x.label===lbl);
        if (s) {
          if (typeof act.x === 'number') s.x = act.x;
          if (typeof act.y === 'number') s.y = act.y;
          changed=true;
        }
        break;
      }
      case 'rename_state': {
        const oldLabel = act.oldLabel, newLabel = act.newLabel;
        if (!oldLabel || !newLabel) break;
        if (automaton.states.some(s=>s.label===newLabel)) break; // avoid collision
        const s = automaton.states.find(x => x.label===oldLabel);
        if (s) { s.label = newLabel;
          automaton.transitions.forEach(t => {
            if (t.from===oldLabel) t.from = newLabel;
            if (t.to===oldLabel) t.to = newLabel;
          });
          changed=true;
        }
        break;
      }
      default:
        // unknown action - ignore
        console.warn('Unknown action:', act);
    }
  }
  if (changed) {
    saveHistory();
    updateCheckboxes();
  }
  return changed;
}

/* Build the instruction prompt for the model. We instruct it to respond with JSON only. */
function buildPrompt(userText, automatonSnapshot, mode='apply') {
  /* mode: 'apply' -> model should return JSON of actions to apply.
     mode: 'explain' -> model may return text explanation (no actions).
  */
  const system = `You are an assistant that edits finite automata models. 
You will be given the current automaton as JSON and a user's instruction. 
When asked to make changes, STRICTLY return valid JSON (no extra commentary) in the EXACT format:
{
  "actions": [
    { "type": "add_state", "label": "A", "x": 120, "y": 100, "isStart": false, "isAccept": false },
    { "type": "add_transition", "from": "A", "to": "B", "symbols": ["0","1"] },
    { "type": "set_start", "label": "A" },
    { "type": "set_accept", "label": "B", "value": true },
    { "type": "remove_state", "label": "X" },
    { "type": "move_state", "label":"A", "x":200, "y":300 },
    { "type": "rename_state", "oldLabel":"A","newLabel":"S" }
  ]
}
If you cannot map the user's instruction to such actions, return {"error":"explanation text"} as JSON.
If the user asked only to explain or ask questions, you may return a plain-text explanation in the "explain" mode.
Do NOT include any other text or commentary when returning JSON.`;

  const current = JSON.stringify(automatonSnapshot, null, 2);
  const userPrompt = `Current automaton:\n${current}\n\nUser instruction:\n"""${userText}"""\n\nIf possible produce JSON with actions (see system instructions).`;
  return system + "\n\n" + userPrompt;
}

/* handle click: send to AI and try to apply actions */
async function handleAIRequest(userText, explainOnly=false) {
  if (!userText || !userText.trim()) { resultEl.textContent = 'Please type an instruction.'; return; }
  resultEl.textContent = 'Contacting AI…';

  // prepare snapshot
  const snapshot = serializeAutomatonForPrompt();
  const fullPrompt = buildPrompt(userText, snapshot, explainOnly ? 'explain' : 'apply');

  try {
    const { raw, text } = await callAI(fullPrompt);
    if (!text) {
      resultEl.textContent = 'AI returned no text.';
      console.log(raw);
      return;
    }

    // if explainOnly: show text and exit
    if (explainOnly) {
      resultEl.textContent = text;
      return;
    }

    // try to extract JSON from text. Models sometimes wrap JSON — find first "{" and last "}".
    const first = text.indexOf('{');
    const last = text.lastIndexOf('}');
    if (first >=0 && last >=0 && last > first) {
      const candidateJson = text.slice(first, last+1);
      let parsed = null;
      try {
        parsed = JSON.parse(candidateJson);
      } catch (err) {
        // fallback: use raw text (display)
        resultEl.textContent = 'AI returned non-parseable JSON. Showing raw response below:\n' + text;
        return;
      }
      if (parsed.error) {
        resultEl.textContent = 'AI says: ' + parsed.error;
        return;
      }
      if (!Array.isArray(parsed.actions)) {
        resultEl.textContent = 'AI returned JSON but no "actions" array was found. Raw response:\n' + text;
        return;
      }

      const applied = applyActions(parsed.actions);
      resultEl.textContent = applied ? 'Applied actions from AI.' : 'No changes were applied (actions may be no-ops).';
      return;
    } else {
      resultEl.textContent = 'AI did not return JSON. Response:\n' + text;
    }
  } catch (err) {
    console.error(err);
    resultEl.textContent = 'Error calling AI: ' + String(err.message || err);
  }
}

/* button hooks */
aisubmitbtn.addEventListener('click', async () => {
  const text = userInputEl.value;
  await handleAIRequest(text, false);
});

explainBtn.addEventListener('click', async () => {
  const text = userInputEl.value;
  await handleAIRequest(text, true);
});

/* small info button behavior */
document.getElementById('info-btn').addEventListener('click', () => {
  alert('AI expects to return JSON with actions. Example user inputs: \n• add state S at 200,200\n• add transition q0->q1:0,1\n• make q1 final\n• set q2 start\n• delete state q3\n• move q0 to 120,240\nIf the AI returns JSON actions they will be applied automatically.');
});

/* initialize */
saveHistory();
updateCheckboxes();

</script>
</body>
</html>
