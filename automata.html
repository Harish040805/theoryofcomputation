<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Automata Simulator</title>
    <link rel="stylesheet" href="automatacss.css">
</head>
<body>
<script>
const iframe = document.createElement('iframe');
iframe.style.position = 'fixed';
iframe.style.top = '0';
iframe.style.left = '0';
iframe.style.width = '100%';
iframe.style.height = '100%';
iframe.style.zIndex = '9999';
iframe.style.border = 'none';

const iframeContent = `
  <html>
    <head>
      <style>
        button {
          padding: 10px 20px; 
          border: 2px solid #ff6666; 
          border-radius: 5px; 
          background-color: #000; 
          color: #ff6666; 
          cursor: pointer;
        }
        button:hover {
          background-color: #ff6666 ;
          color: #000;
        }
      </style>
    </head>
    <body style="font-family: Arial, sans-serif; background-color: #000; text-align: center; margin-top: 20%;">
      <h1 style="color: #fff;">Automata Simulator</h1>
      <button onclick="parent.document.body.removeChild(parent.document.querySelector('iframe'));">Enter</button>
    </body>
  </html>
`;

iframe.srcdoc = iframeContent;
document.body.appendChild(iframe);
</script>
<div id="notification" class="notification">
  <div class="notification-message">
    <div class="notification-title">Instructions</div>
        * First, add states by clicking the "Vertex" button and labeling each state.<br>
        * To add transitions between states, enable the "Edge" mode by clicking the Edge button.<br>
        * In Edge mode, click on the source state then the destination state to create a transition.<br>
        * Each transition requires an input symbol (single character) to label the edge.<br>
        * Only one transition per symbol from a given state is allowed (DFA rule).<br>
        * The "Undo" button reverts your last action.<br>
        * The "Reset" button clears all states and transitions.<br>
        * To simulate your automaton, click the "Solve" button and enter an input string.<br>
        * The simulation will show if the input string is accepted or rejected based on final states.<br>
        * Use the "Delete" button to remove states or transitions by clicking on them.<br>
  </div>
  <button class="notification-close">OK</button>
</div>    
  <button id="info-btn" title="Info">i</button>
  <div id="iframe-overlay" style="display: none;">
    <div id="iframe-wrapper">
      <button id="close-iframe-btn" title="Close">×</button>
      <iframe src="info.html"></iframe>
    </div>
  </div>
<div id="acceptModal">
  <p>Is this a final state?</p>
  <button id="yesBtn">Yes</button>
  <button id="noBtn">No</button>
</div>

<center>
<div class="container">
    <div id="main-content" style="width: 100%; height: 100%; float: center;">
        <h1>Automata Simulator</h1>
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
        <canvas id="canvas" width="1150" height="550"></canvas>
        <table>
                <tr>
                    <th>Feature</th>
                    <th>Present?</th>
                </tr>
<tr>
    <td>Deterministic Automaton (DFA)</td>
    <td>
      <label class="custom-checkbox">
        <input type="checkbox" id="deterministic" disabled />
        <span class="checkmark"></span>
      </label>
    </td>
  </tr>
  <tr>
    <td>Non-deterministic Automaton (NFA)</td>
    <td>
      <label class="custom-checkbox">
        <input type="checkbox" id="nondeterministic" disabled />
        <span class="checkmark"></span>
      </label>
    </td>
  </tr>
  <tr>
    <td>Has Epsilon (ε) Transitions</td>
    <td>
      <label class="custom-checkbox">
        <input type="checkbox" id="epsilon" disabled />
        <span class="checkmark"></span>
      </label>
    </td>
  </tr>
  <tr>
    <td>Start State Defined</td>
    <td>
      <label class="custom-checkbox">
        <input type="checkbox" id="start-state" disabled />
        <span class="checkmark"></span>
      </label>
    </td>
  </tr>
  <tr>
    <td>Accept (Final) State(s) Present</td>
    <td>
      <label class="custom-checkbox">
        <input type="checkbox" id="accept-state" disabled />
        <span class="checkmark"></span>
      </label>
    </td>
  </tr>
            </table>
        </div>
        <div class="button-container">
            <button id="vertex-btn" title="Add a new state">Vertex</button>
            <button id="edge-btn" title="Toggle transition (edge) mode">Edge</button>
            <button id="self-loop-btn" title="Self Loop">Self Loop</button>
            <button id="undo-btn" title="Undo last action">Undo</button>
            <button id="reset-btn" title="Reset automaton">Reset</button>
            <button id="delete-btn" title="Delete state or transition">Delete</button>
<div class="p-4">
    <textarea id="user-input" placeholder="Type your message here..."></textarea>
    <button id="aisubmitbtn">Submit</button>
    <div id="result"></div>
</div>
 <script>
        const userInput = document.getElementById('user-input');
        const aisubmitbtn = document.getElementById('aisubmitbtn');
        const result = document.getElementById('result');

        aisubmitbtn.addEventListener('click', async function () {
            const val = userInput.value;

            const response = await fetch(
                "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyC5ab-HZmvtoTEXMRBMb4-tPpwD2yMVF1A",
                {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: val }] }]
                    })
                }
            );

            const data = await response.json();
            console.log(data);

            if (data?.candidates?.length) {
                result.innerHTML = `<p>${data.candidates[0].content.parts[0].text}</p>`;
            } else {
                result.innerHTML = "<p>Error: No response</p>";
            }
        });
    </script>
        </div>
    </div>                
</div>
</center>
<script>
const notificationBox = document.querySelector('.notification');
const notificationCloseButton = document.querySelector('.notification-close');

notificationBox.style.display = 'block';

notificationCloseButton.addEventListener('click', () => {
    notificationBox.classList.add('hide');
    setTimeout(() => {
        notificationBox.style.display = 'none';
    }, 300);
});

let automaton = {
    states: [],          
    transitions: [],     
    alphabet: new Set(),
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let draggingState = null;
let offsetX = 0;
let offsetY = 0;

let isTransitionMode = false;
let transitionFromState = null;

let isSelfLoopMode = false;

let history = [];
let historyIndex = -1;

function drawAutomaton() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    automaton.transitions.forEach((trans) => {
        const from = trans.from;
        const to = trans.to;

        if (from === to) {
            ctx.beginPath();
            ctx.arc(from.x, from.y - 30, 20, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = 'red';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(trans.symbols.join(','), from.x, from.y - 50);
        } else {
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();

            let angle = Math.atan2(to.y - from.y, to.x - from.x);
            let arrowSize = 10;
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - arrowSize * Math.cos(angle - Math.PI / 6), to.y - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - arrowSize * Math.cos(angle + Math.PI / 6), to.y - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(to.x, to.y);
            ctx.fillStyle = 'white';
            ctx.fill();

            const midX = (from.x + to.x) / 2;
            const midY = (from.y + to.y) / 2;
            ctx.fillStyle = 'red';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(trans.symbols.join(','), midX, midY - 10);
        }
    });

    automaton.states.forEach((state) => {
        ctx.beginPath();
        ctx.arc(state.x, state.y, 25, 0, 2 * Math.PI);
        ctx.fillStyle = '#ff6666';
        ctx.fill();

        if (state.isAccept) {
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#ffd700'; 
            ctx.beginPath();
            ctx.arc(state.x, state.y, 30, 0, 2 * Math.PI);
            ctx.stroke();
        } else {
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ff6666';
            ctx.beginPath();
            ctx.arc(state.x, state.y, 25, 0, 2 * Math.PI);
            ctx.stroke();
        }

        if(state.isStart) {
            ctx.beginPath();
            ctx.moveTo(state.x - 40, state.y);
            ctx.lineTo(state.x - 25, state.y);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(state.x - 30, state.y - 7);
            ctx.lineTo(state.x - 40, state.y);
            ctx.lineTo(state.x - 30, state.y + 7);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(state.label, state.x, state.y);
    });
}

setInterval(drawAutomaton, 100);

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    automaton.states.forEach((state) => {
        if (Math.hypot(x - state.x, y - state.y) < 25) {
            draggingState = state;
            offsetX = x - state.x;
            offsetY = y - state.y;
            // saveHistory();  // Commented out to avoid spamming history during drag
        }
    });
});

canvas.addEventListener('mousemove', (e) => {
    if (draggingState) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        draggingState.x = x - offsetX;
        draggingState.y = y - offsetY;
    }

    if (isTransitionMode && transitionFromState) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawAutomaton();

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        ctx.beginPath();
        ctx.moveTo(transitionFromState.x, transitionFromState.y);
        ctx.lineTo(x, y);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();

        let angle = Math.atan2(y - transitionFromState.y, x - transitionFromState.x);
        let arrowSize = 10;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - arrowSize * Math.cos(angle - Math.PI / 6), y - arrowSize * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x - arrowSize * Math.cos(angle + Math.PI / 6), y - arrowSize * Math.sin(angle + Math.PI / 6));
        ctx.lineTo(x, y);
        ctx.fillStyle = 'black';
        ctx.fill();
    }
});

canvas.addEventListener('mouseup', (e) => {
    if(draggingState) {
      saveHistory();  
    }
    draggingState = null;
});

canvas.addEventListener('click', (e) => {
    if (isTransitionMode) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let clickedState = null;
        automaton.states.forEach((state) => {
            if (Math.hypot(x - state.x, y - state.y) < 25) {
                clickedState = state;
            }
        });

        if (!transitionFromState) {
            if(clickedState) transitionFromState = clickedState;
        } else if(clickedState) {
            let symbol = prompt('Enter input symbol(s) separated by comma:');
            if(symbol) {
                const symbols = symbol.split(',').map(s => s.trim());
                const existingTransition = automaton.transitions.find(t => t.from === transitionFromState && t.to === clickedState);
                if (existingTransition) {
                    existingTransition.symbols.push(...symbols);
                } else {
                    automaton.transitions.push({
                        from: transitionFromState,
                        to: clickedState,
                        symbols: symbols
                    });
                }
                symbols.forEach(s => automaton.alphabet.add(s));
                saveHistory();
            }
            transitionFromState = null;
        }
    }

    if (isSelfLoopMode) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let clickedState = null;
        automaton.states.forEach((state) => {
            if (Math.hypot(x - state.x, y - state.y) < 25) {
                clickedState = state;
            }
        });

        if (clickedState) {
            let symbol = prompt('Enter input symbol(s) separated by comma:');
            if(symbol) {
                const symbols = symbol.split(',').map(s => s.trim());
                const existingTransition = automaton.transitions.find(t => t.from === clickedState && t.to === clickedState);
                if (existingTransition) {
                    existingTransition.symbols.push(...symbols);
                } else {
                    automaton.transitions.push({
                        from: clickedState,
                        to: clickedState,
                        symbols: symbols
                    });
                }
                symbols.forEach(s => automaton.alphabet.add(s));
                saveHistory();
            }
            isSelfLoopMode = false;
        }
    }
});

document.getElementById('edge-btn').addEventListener('click', () => {
    isTransitionMode = !isTransitionMode;
    transitionFromState = null;
    alert(isTransitionMode ? 'Transition Mode Enabled: Click source and destination states to add transition.' : 'Transition Mode Disabled');
    saveHistory();
});

document.getElementById('self-loop-btn').addEventListener('click', () => {
    isSelfLoopMode = !isSelfLoopMode;
    if (isSelfLoopMode) {
        alert("Click the vertex to have self loop. This button works only once at a time. To have self loop for another vertex, click this button once again and click the next vertex.");
    }
});

async function askAcceptState() {
  return new Promise((resolve) => {
    const modal = document.getElementById('acceptModal');
    modal.style.display = 'block';

    const yesBtn = document.getElementById('yesBtn');
    const noBtn = document.getElementById('noBtn');

    function cleanup() {
      modal.style.display = 'none';
      yesBtn.removeEventListener('click', onYes);
      noBtn.removeEventListener('click', onNo);
    }

    function onYes() {
      cleanup();
      resolve(true);
    }

    function onNo() {
      cleanup();
      resolve(false);
    }

    yesBtn.addEventListener('click', onYes);
    noBtn.addEventListener('click', onNo);
  });
}

function saveHistory() {
    const snapshot = {
        states: JSON.parse(JSON.stringify(automaton.states)),
        transitions: JSON.parse(JSON.stringify(automaton.transitions)),
        alphabet: new Set(automaton.alphabet),
    };
    history = history.slice(0, historyIndex + 1);
    history.push(snapshot);
    historyIndex++;
}

document.getElementById('undo-btn').addEventListener('click', () => {
    if (historyIndex > 0) {
        historyIndex--;
        const snapshot = history[historyIndex];
        automaton.states = JSON.parse(JSON.stringify(snapshot.states));
        automaton.transitions = JSON.parse(JSON.stringify(snapshot.transitions));
        automaton.alphabet = new Set(snapshot.alphabet);
    }
});

document.getElementById('reset-btn').addEventListener('click', () => {
    automaton.states = [];
    automaton.transitions = [];
    automaton.alphabet = new Set();
    history = [];
    historyIndex = -1;
});

document.getElementById('vertex-btn').addEventListener('click', async () => {
    const rect = canvas.getBoundingClientRect();
    const x = rect.width / 2;
    const y = rect.height / 2;

    let label = prompt("Enter state label:");
    if(!label) {
        alert('Label cannot be empty');
        return;
    }
    if(automaton.states.find(s => s.label === label)) {
        alert('State label must be unique');
        return;
    }

    let isStart = false;
    if(automaton.states.length === 0) {
        isStart = confirm('Make this the start state? (Only one start state allowed)');
    }

    let isAccept = await askAcceptState();

    automaton.states.push({ x, y, label, isStart, isAccept });
    saveHistory();
    updateCheckboxes();
});

function updateCheckboxes() {
    document.getElementById('deterministic').checked = true; 
    document.getElementById('nondeterministic').checked = false; 
    document.getElementById('epsilon').checked = false; 
    document.getElementById('start-state').checked = automaton.states.some(s => s.isStart);
    document.getElementById('accept-state').checked = automaton.states.some(s => s.isAccept);
}
</script>
</body>
</html>

